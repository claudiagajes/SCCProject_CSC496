{
  "_args": [
    [
      {
        "raw": "json-query",
        "scope": null,
        "escapedName": "json-query",
        "name": "json-query",
        "rawSpec": "",
        "spec": "latest",
        "type": "tag"
      },
      "D:\\Claudia\\Documents\\School\\csc496_project"
    ]
  ],
  "_from": "json-query@latest",
  "_id": "json-query@2.2.2",
  "_inCache": true,
  "_location": "/json-query",
  "_nodeVersion": "6.4.0",
  "_npmOperationalInternal": {
    "host": "packages-18-east.internal.npmjs.com",
    "tmp": "tmp/json-query-2.2.2.tgz_1491376361718_0.08927279338240623"
  },
  "_npmUser": {
    "name": "mmckegg",
    "email": "matt@wetsand.co.nz"
  },
  "_npmVersion": "3.10.3",
  "_phantomChildren": {},
  "_requested": {
    "raw": "json-query",
    "scope": null,
    "escapedName": "json-query",
    "name": "json-query",
    "rawSpec": "",
    "spec": "latest",
    "type": "tag"
  },
  "_requiredBy": [
    "#USER"
  ],
  "_resolved": "https://registry.npmjs.org/json-query/-/json-query-2.2.2.tgz",
  "_shasum": "b6558b8a3794ccd217926aa38024324b77b48ab1",
  "_shrinkwrap": null,
  "_spec": "json-query",
  "_where": "D:\\Claudia\\Documents\\School\\csc496_project",
  "author": {
    "name": "Matt McKegg",
    "email": "matt@wetsand.co.nz",
    "url": "http://twitter.com/MattMcKegg"
  },
  "bugs": {
    "url": "https://github.com/mmckegg/json-query/issues"
  },
  "dependencies": {},
  "description": "Retrieves values from JSON objects for data binding. Offers params, nested queries, deep queries, custom reduce/filter functions and simple boolean logic. Browserify compatible.",
  "devDependencies": {
    "ava": "^0.14.0",
    "es5-shim": "~2.1.0",
    "tape": "*"
  },
  "directories": {},
  "dist": {
    "shasum": "b6558b8a3794ccd217926aa38024324b77b48ab1",
    "tarball": "https://registry.npmjs.org/json-query/-/json-query-2.2.2.tgz"
  },
  "engines": {
    "node": "*"
  },
  "gitHead": "fb9e676236ab6a3bf2d89f7e370f42f0bd56044e",
  "homepage": "http://github.com/mmckegg/json-query",
  "keywords": [
    "data binding",
    "filter",
    "json",
    "query"
  ],
  "main": "index.js",
  "maintainers": [
    {
      "name": "mmckegg",
      "email": "matt@wetsand.co.nz"
    }
  ],
  "name": "json-query",
  "optionalDependencies": {},
  "readme": "json-query\n===\n\nRetrieves values from JSON objects for data binding. Offers params, nested queries, deep queries, custom reduce/filter functions and simple boolean logic.\n\n## Install via [npm](https://www.npmjs.com/package/json-query)\n\n```bash\n$ npm install json-query\n```\n\n## API\n\n```js\nvar jsonQuery = require('json-query')\n```\n\n### `jsonQuery(query, options)`\n\nSpecify a query and what to query. Returns an object that describes the result of the query.\n\n```js\n\nvar data = {\n  people: [\n    {name: 'Matt', country: 'NZ'},\n    {name: 'Pete', country: 'AU'},\n    {name: 'Mikey', country: 'NZ'}\n  ]\n}\n\njsonQuery('people[country=NZ].name', {\n  data: data\n}) //=> {value: 'Matt', parents: [...], key: 0} ... etc\n```\n\n#### Options:\n\n- **`data`** or **`rootContext`**: The main object to query.\n- **`source`** or **`context`** (optional): The current object we're interested in. Accessed in query with `.`.\n- **`parent`** (optional): An additional context for looking further up the tree. Accessed by `..`.\n- **`locals`**: Specify an object containing helper functions. Accessed by `':filterName'`. Expects `function(input, args...)` with `this` set to original passed in options.\n- **`globals`**: Falls back to globals when no local function found.\n- **`force`** (optional): Specify an object to be returned from the query if the query fails. It will be saved into the place the query expected the object to be.\n- **`allowRegexp`** (optional): Enable the `~` operator. Before enabling regexp match to anyone, consider the [user defined regular expression security concerns](http://stackoverflow.com/questions/20928677/user-defined-regular-expression-security-concerns).\n\n## Queries\n\nQueries are strings that describe an object or value to pluck out, or manipulate from the context object. The syntax is a little bit CSS, a little bit JS, but pretty powerful.\n\n### Accessing properties (dot notation)\n\n`person.name`\n\n### Array accessors\n\n`people[0]`\n\n### Array pluck\n\n`people.name` => return all the names of people\n\n### Get all values of a lookup\n\n`lookup[*]`\n\n### Array filter\n\nBy default **only the first** matching item will be returned:\n\n`people[name=Matt]`\n\nBut if you add an asterisk (`*`), **all** matching items will be returned:\n\n`people[*country=NZ]`\n\nYou can use comparative operators:\n\n`people[*rating>=3]`\n\nOr use boolean logic:\n\n`people[* rating >= 3 & starred = true]`\n\nIf `options.enableRegexp` is enabled, you can use the `~` operator to match `RegExp`:\n\n`people[*name~/^R/i]`\n\nYou can also **negate** any of the above examples by adding a `!` before the `=` or `~`:\n\n`people[*country!=NZ]`\n\n### Or syntax\n\n`person.greetingName|person.name`\n\n### Deep queries\n\nSearch through multiple levels of Objects/Arrays using `[**]`:\n\n```js\nvar data = {\n  grouped_people: {\n    'friends': [\n      {name: 'Steve', country: 'NZ'},\n      {name: 'Jane', country: 'US'},\n      {name: 'Mike', country: 'AU'},\n      {name: 'Mary', country: 'NZ'},\n    ],\n    'enemies': [\n      {name: 'Evil Steve', country: 'AU'}\n      {name: 'Betty', country: 'NZ'},\n    ]\n  }\n}\n\nvar result = jsonQuery('grouped_people[**][*country=NZ]', {data: data}).value\n```\n\nThe `result` will be:\n\n```js\n[\n  {name: 'Steve', country: 'NZ'},\n  {name: 'Mary', country: 'NZ'},\n  {name: 'Betty', country: 'NZ'}\n]\n```\n\n### Inner queries\n\n```js\nvar data = {\n  page: {\n    id: 'page_1',\n    title: 'Test'\n  },\n  comments_lookup: {\n    'page_1': [\n      {id: 'comment_1', parent_id: 'page_1', content: \"I am a comment\"}\n    ]\n  }\n}\n\n// get the comments that match page's id\njsonQuery('comments_lookup[{page.id}]', {data: data})\n```\n\n### Local functions (helpers)\n\nAllows you to hack the query system to do just about anything.\n\nSome nicely contrived examples:\n\n```js\nvar helpers = {\n  greetingName: function(input){\n    if (input.known_as){\n      return input.known_as\n    } else {\n      return input.name\n    }\n  },\n  and: function(inputA, inputB){\n    return inputA && inputB\n  },\n  text: function(input, text){\n    return text\n  },\n  then: function(input, thenValue, elseValue){\n    if (input){\n      return thenValue\n    } else {\n      return elseValue\n    }\n  }\n}\n\nvar data = {\n  is_fullscreen: true,\n  is_playing: false,\n  user: {\n    name: \"Matthew McKegg\",\n    known_as: \"Matt\"\n  }\n}\n\njsonQuery('user:greetingName', {\n  data: data, locals: helpers\n}).value //=> \"Matt\"\n\njsonQuery(['is_fullscreen:and({is_playing}):then(?, ?)', \"Playing big!\", \"Not so much\"], {\n  data: data, locals: helpers\n}).value //=> \"Not so much\"\n\njsonQuery(':text(This displays text cos we made it so)', {\n  locals: helpers\n}).value //=> \"This displays text cos we made it so\"\n\n```\n\nOr you could add a `select` helper:\n\n```js\njsonQuery('people:select(name, country)', {\n  data: data,\n  locals: {\n    select: function (input) {\n      if (Array.isArray(input)) {\n        var keys = [].slice.call(arguments, 1)\n        return input.map(function (item) {\n          return Object.keys(item).reduce(function (result, key) {\n            if (~keys.indexOf(key)) {\n              result[key] = item[key]\n            }\n            return result\n          }, {})\n        })\n      }\n    }\n  }\n})\n```\n\nYou can also use helper functions inside array filtering:\n\n```js\njsonQuery('people[*:recentlyUpdated]', {\n  data: data,\n  locals: {\n    recentlyUpdated: function (item) {\n      return item.updatedAt < Date.now() - (30 * 24 * 60 * 60 * 1000)\n    }\n  }\n})\n```\n\n### Context\n\nSpecifying context (`data`, `source`, and `parent` options) is good for databinding and working on a specific object and still keeping the big picture available.\n\n```js\nvar data = {\n  styles: {\n    bold: 'font-weight:strong',\n    red: 'color: red'\n  },\n  paragraphs: [\n    {content: \"I am a red paragraph\", style: 'red'},\n    {content: \"I am a bold paragraph\", style: 'bold'},\n  ],\n}\n\nvar pageHtml = ''\ndata.paragraphs.forEach(function(paragraph){\n  var style = jsonQuery('styles[{.style}]', {data: data, source: paragraph}).value\n  var content = jsonQuery('.content', data: data, source: paragraph) // pretty pointless :)\n  pageHtml += \"<p style='\" + style \"'>\" + content + \"</p>\"\n})\n```\n\n## Query Params\n\nParams can be specified by passing in an array with the first param the query (with `?` params) and subsequent params.\n\n```js\njsonQuery(['people[country=?]', 'NZ'])\n```\n\n## License\n\nMIT\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git://github.com/mmckegg/json-query.git"
  },
  "scripts": {
    "test": "tape test/*.js --tap"
  },
  "testling": {
    "files": "test/*.js",
    "browsers": [
      "chrome/20.0",
      "chrome/25.0",
      "chrome/latest",
      "chrome/canary",
      "firefox/3.6",
      "firefox/20.0",
      "firefox/latest",
      "firefox/nightly",
      "opera/12.0",
      "opera/latest",
      "safari/4.0",
      "safari/latest",
      "opera/next",
      "iphone/6.0..latest",
      "ipad/6.0..latest",
      "safari/6.0..latest",
      "android-browser/4.2..latest",
      "iexplore/6.0",
      "iexplore/9.0..latest"
    ]
  },
  "version": "2.2.2"
}
